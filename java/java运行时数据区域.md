>github上的地址：[DevelopBlog](https://github.com/Vinctor/DevelopBlog)

# 概览
java虚拟机(以下简称JVM)多种多样,其中都必须遵循《java虚拟机规范》的要求,本篇文章只讨论```hotspot```（SE7）.
JVM在运行程序时,会把内存划分为几个不同的区域,以方便线程的切换,GC,内存的高效利用等,java运行时数据区域示意图如下:

![运行时数据区域示意图.png](http://upload-images.jianshu.io/upload_images/1583231-2baf95bd2f9e03ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500)
>其中```方法区```和```堆```为线程共享的区域

## 程序计数器
首先了解一下```.class```文件结构：
当我们使用```javac```命令将```.java```文件编译为```.class```文件之时,编译器将类的各项信息按照《java虚拟机规范》中的规范一次写入```.class```文件,其中包括ava版本信息，包名，类信息，字段信息，方法信息等。其中方法块内容将被编译成为可被JVM识别的一条条```字节码指令```。
JVM执行某一方法时，加载```.class```文件之后,JVM的字节码解释器读取文件中的操作指令(一条指令包含操作码与操作数），读取一条执行一条，在多线程任务不断切换中，如何才能记录下各个线程的切换前的某一方法执行的进度呢？```程序计数器```就是为此而生，用来记录正在执行的JVM的字节码的指令地址。由于它记录的是某一条线程的执行进度，故他也是线程独享的。

## 虚拟机栈
此部分即我们经常提起的```java堆栈```中的```栈```。他的生性周期与线程相同，虚拟机中存储是以```栈帧```为单位的，栈帧是虚拟机栈的的元素，在JVM执行一新的方法时，JVM会创建一个栈帧，该栈帧入栈，方法执行结束后，该栈帧出。
栈帧用来存储线程执行过程时方法中的局部变量表，操作数栈，方法出口等其他信息。
局部变量表即是我们经常讨论的部分，他存储了基础类型（int，double，boolean等），对象引用（不是对象本身，而是一个对象的内存地址）和returnAddress地址（前面提到的字节码指令的地址）。
如图所示：

![线程，虚拟机栈，栈帧](http://upload-images.jianshu.io/upload_images/1583231-8b0bafd93dde0ea6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500)

## 本地方法栈
与```虚拟机栈```类似，区别在于它用来在虚拟机执行Native方法时使用

## 堆
java开发中经常提及的，JVM运行时数据区域中最大的一块，它的唯一作用就是存放实例化后的对象以及数组。同时也是```GC```的主要区域。虚拟机栈中存储了堆中对象的指针地址。
```GC```垃圾回收采用分代的思想来管理内存，在内存回收的角度来看，堆分为```老年代```和```新生代```。
新生代是指新创建的对象，老年代是指存活时间比较长，经过多轮GC任然存活的对象。
![老年代，新生代](http://upload-images.jianshu.io/upload_images/1583231-ded365aecf740b69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800)
先介绍一下两种GC类型：
```新生代GC（Minor GC）```：指发生在新生代的垃圾回收，因为java中大多数的java对象存活时间都不会很长，具备```朝生夕灭```的特点，所以```Minor GC```的回收速度特别快，也特别频繁。
```老年代GC（Major GC/Full GC）```：指发生带老年代的GC，大多数情况下会伴随发生至少一次的新生代GC（Minor GC），由于使用不同的垃圾回收算法，故而回收速度非常慢。
(关于GC的算法以及常见垃圾回收器，将在另一篇文章中讲解)
>新生代是如何晋升为老年代呢？

参照上图：
```Survivor```分为两个区域，被称为```S0```和```S1```，两个区域总有一个是空闲的。
#### 步骤如下：
* 新出生的对象优先存活在```Eden```区域（```Eden```不够时，发起一次```Minor GC```），java在每个对象创建时，为每个对象定义了一个年龄计数器，用于标记一个对象的存活时间。

* 第一次```Minor GC```新生代GC发生之后，如果该对象仍然存活，他的年龄+1，并将它从```Eden```移至```Survivor```中de ```S0```区域（这时```Eden```和```S1```区域为空）。

*当再次发生 ```Minor GC```时，此时回收的区域为```Eden```和```S0```区域，此时```S0```区域没有被回收的对象年龄+1。此时重点来了！```S0```对象有两个去处，如果达到最大年龄（默认15）的对象直接移动到老年代中，没有到达年龄的对象的对象全部移至```S1```区域,```S0```清空；而```Eden```和上一步骤同样，存活对象移至```S1```如下图：

![image.png](http://upload-images.jianshu.io/upload_images/1583231-eb98f93cf93811bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800)

此次GC完成之后,```S0```和```Eden```为空 如下图


![image.png](http://upload-images.jianshu.io/upload_images/1583231-f2c6fb174d39da32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800)


此后，

再次发生GC之后，```Eden```和```S1```发生回收，将对象移至```S0```中，完成之后，```Eden```和```S1```为空；

再次发生GC之后，```Eden```和```S0```发生回收，将对象移至```S1```中，完成之后，```Eden```和```S0```为空；

依此循环，直至年龄达到一定程度（默认15），对象进入老年代。

年龄最大值默认为15，   可以通过参数  -XX  MaxTenuringThreshold 设置


## 方法区
方法区
他存储的是已经被JVM加载的类信息，常量池，静态变量，JVM即使编译器等数据，同样也是线程共享区域。他经常被看成是```堆```的逻辑部分，为了方便这部分内存管理，JVM将垃圾回收范围扩展至方法区，在```GC```中被称为```永久区```(上图中的```Permanent```)，故而他经常被称为```非堆```，与java堆进行区分。
GC对此部分的回收主要集中在对常量池的回收以及类型的卸载。
> 常量池

常量池是方法区的一部分，用于存放由```javac```编译时生成的```.class```文件中的常量（例如：包名，类名，方法名，字段名，String字符串等,如下图）。

![class文件中字节码常量类型](http://upload-images.jianshu.io/upload_images/1583231-3ce64ddf3c5778ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800)


著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
